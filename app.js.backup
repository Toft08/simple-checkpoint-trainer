// Refactored app.js using state manager - much cleaner and shorter!

class TrainerApp extends StateComponent {
    constructor() {
        super('trainer-app');
        this.exerciseGenerator = null;
        this.init();
    }

    async init() {
        // Load config from localStorage or use defaults
        const savedConfig = this.loadStoredConfig();
        this.dispatch(Actions.setConfig(savedConfig));
        
        // Initialize exercise generator
        this.exerciseGenerator = new DynamicExerciseGenerator(savedConfig);
        
        // Set up state subscriptions for automatic UI updates
        this.setupStateSubscriptions();
        
        // Initialize UI
        this.displayConfigSummary();
        this.setupEventListeners();
        
        // Load first exercise
        await this.loadExercise(0);
        
        this.mount();
    }

    setupStateSubscriptions() {
        // Subscribe to progress changes
        this.onStateChange((newState, prevState) => {
            if (newState.progress !== prevState.progress) {
                this.updateProgressUI(newState.progress);
            }
        });

        // Subscribe to current exercise changes
        this.onStateChange((newState, prevState) => {
            if (newState.currentExercise !== prevState.currentExercise) {
                this.renderExercise(newState.currentExercise);
            }
        });

        // Subscribe to UI state changes
        this.onStateChange((newState, prevState) => {
            if (newState.ui !== prevState.ui) {
                this.updateUI(newState.ui);
            }
        });

        // Subscribe to navigation state
        this.onStateChange(() => {
            this.updateNavigationButtons();
        });
    }

    loadStoredConfig() {
        try {
            const stored = localStorage.getItem('trainingConfig');
            return stored ? JSON.parse(stored) : {
                tasks: 5,
                levels: ['g1', 'g2'],
                difficulty: 0.5
            };
        } catch (error) {
            console.error('Error loading config:', error);
            return { tasks: 5, levels: ['g1', 'g2'], difficulty: 0.5 };
        }
    }

    displayConfigSummary() {
        const config = Selectors.getConfig();
        const levelNames = config.levels.map(level => level.toUpperCase()).join(', ');
        const difficultyName = this.getDifficultyName(config.difficulty);
        
        const configDisplay = document.createElement('div');
        configDisplay.className = 'config-display';
        configDisplay.innerHTML = `
            <div class="session-info">
                üìä ${config.tasks} tasks ‚Ä¢ üéì ${levelNames} ‚Ä¢ üî• ${difficultyName} (${Math.round(config.difficulty * 100)}%)
                <button class="config-change-btn" onclick="window.location.href='index.html'">‚öôÔ∏è Change</button>
            </div>
        `;
        
        const container = document.querySelector('.container');
        if (container) {
            container.insertBefore(configDisplay, container.firstChild);
        }
    }

    setupEventListeners() {
        // Previous button
        document.getElementById('prev-btn')?.addEventListener('click', () => {
            this.dispatch(Actions.prevExercise());
        });

        // Next button
        document.getElementById('next-btn')?.addEventListener('click', () => {
            this.dispatch(Actions.nextExercise());
        });

        // Check button
        document.getElementById('check-btn')?.addEventListener('click', () => {
            this.checkAnswer();
        });

        // README button
        document.getElementById('readme-btn')?.addEventListener('click', () => {
            this.dispatch(Actions.showReadme());
        });

        // Close README
        document.getElementById('close-readme')?.addEventListener('click', () => {
            this.dispatch(Actions.hideReadme());
        });

        // Regenerate button
        document.getElementById('regenerate-btn')?.addEventListener('click', () => {
            this.regenerateExercise();
        });

        // README modal click outside to close
        document.getElementById('readme-modal')?.addEventListener('click', (e) => {
            if (e.target.id === 'readme-modal') {
                this.dispatch(Actions.hideReadme());
            }
        });

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            const canGoPrev = Selectors.canGoPrev();
            const canGoNext = Selectors.canGoNext();
            
            if (e.key === 'ArrowLeft' && canGoPrev) {
                this.dispatch(Actions.prevExercise());
            } else if (e.key === 'ArrowRight' && canGoNext) {
                this.dispatch(Actions.nextExercise());
            } else if (e.key === ' ') {
                e.preventDefault();
                this.checkAnswer();
            }
        });

        // Prevent default drag behavior
        document.addEventListener('dragstart', (e) => {
            if (!e.target.classList.contains('drag-item')) {
                e.preventDefault();
            }
        });
    }

    async loadExercise(index) {
        // Check if exercise is cached
        const cached = Selectors.getCachedExercise(index);
        if (cached) {
            this.dispatch(Actions.setCurrentExercise(index, cached));
            this.updateProgress();
            return;
        }

        // Load exercise dynamically
        this.dispatch(Actions.setLoading(true));
        try {
            const exerciseList = this.exerciseGenerator.getExerciseList();
            if (index >= exerciseList.length) {
                throw new Error('Exercise index out of range');
            }

            const exerciseId = exerciseList[index].id;
            const exercise = await this.exerciseGenerator.loadExercise(exerciseId);
            
            // Cache and set current exercise
            this.dispatch(Actions.cacheExercise(index, exercise));
            this.dispatch(Actions.setCurrentExercise(index, exercise));
            this.updateProgress();
            
        } catch (error) {
            console.error('Failed to load exercise:', error);
            this.dispatch(Actions.setError(error.message));
        } finally {
            this.dispatch(Actions.setLoading(false));
        }
    }

    updateProgress() {
        const current = Selectors.getCurrentExerciseIndex();
        const total = Selectors.getTasks();
        this.dispatch(Actions.updateProgress(current + 1, total));
    }

    updateProgressUI(progress) {
        const progressText = document.getElementById('progress-text');
        const progressFill = document.getElementById('progress-fill');
        
        if (progressText) {
            progressText.textContent = `Exercise ${progress.current} of ${progress.total}`;
        }
        
        if (progressFill) {
            progressFill.style.width = `${progress.percentage}%`;
        }
    }

    renderExercise(exercise) {
        if (!exercise) return;

        const container = document.getElementById('exercise-container');
        if (!container) return;

        // Clear previous content
        container.innerHTML = '';
        
        // Hide results
        const resultContainer = document.getElementById('result-container');
        if (resultContainer) resultContainer.style.display = 'none';

        // Reset check button
        const checkBtn = document.getElementById('check-btn');
        if (checkBtn) {
            checkBtn.textContent = 'Check Answer';
            checkBtn.disabled = false;
        }

        // Create exercise HTML
        const exerciseHTML = `
            <div class="level-badge ${exercise.level}">${exercise.level.toUpperCase()}</div>
            <h2 class="exercise-title">${exercise.title}</h2>
            <p class="exercise-description">${exercise.description}</p>
            ${exercise.type === 'fill-blank' ? this.createFillBlankHTML(exercise) : this.createDragDropHTML(exercise)}
        `;

        container.innerHTML = exerciseHTML;

        // Setup event listeners for exercise
        if (exercise.type === 'fill-blank') {
            this.setupFillBlankListeners();
        } else if (exercise.type === 'drag-drop') {
            this.setupDragDropListeners();
        }
    }

    createFillBlankHTML(exercise) {
        let codeWithBlanks = exercise.code;
        let blankIndex = 0;

        // Replace each _____ with an input field
        codeWithBlanks = codeWithBlanks.replace(/_____/g, function() {
            return `<input type="text" class="blank" data-blank-index="${blankIndex++}" autocomplete="off" spellcheck="false">`;
        });

        return `
            <div class="code-snippet">
                <pre><code>${codeWithBlanks}</code></pre>
            </div>
        `;
    }

    createDragDropHTML(exercise) {
        const shuffledLines = [...exercise.lines].sort(() => Math.random() - 0.5);
        
        return `
            <div class="drag-container">
                <div class="drag-options" id="drag-options">
                    ${shuffledLines.map((line, index) => 
                        `<div class="drag-item" draggable="true" data-line-index="${exercise.lines.indexOf(line)}" data-content="${line.replace(/"/g, '&quot;')}">${line || '(empty line)'}</div>`
                    ).join('')}
                </div>
                
                <div class="code-snippet">
                    <div class="drop-zones">
                        ${exercise.lines.map((_, index) => 
                            `<div class="drop-zone" data-position="${index}">Drop line ${index + 1} here...</div>`
                        ).join('')}
                    </div>
                </div>
            </div>
        `;
    }

    setupFillBlankListeners() {
        const blanks = document.querySelectorAll('.blank');
        blanks.forEach((blank, index) => {
            blank.addEventListener('input', () => {
                blank.classList.remove('correct', 'incorrect');
            });
            
            blank.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    this.checkAnswer();
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    const blanks = document.querySelectorAll('.blank');
                    if (index < blanks.length - 1) {
                        blanks[index + 1].focus();
                    }
                }
            });
        });
    }

    setupDragDropListeners() {
        // Drag and drop implementation (keeping your existing logic)
        const dragItems = document.querySelectorAll('.drag-item');
        const dropZones = document.querySelectorAll('.drop-zone');

        dragItems.forEach(item => {
            item.addEventListener('dragstart', this.handleDragStart.bind(this));
            item.addEventListener('dragend', this.handleDragEnd.bind(this));
        });

        dropZones.forEach(zone => {
            zone.addEventListener('dragover', this.handleDragOver.bind(this));
            zone.addEventListener('drop', this.handleDrop.bind(this));
            zone.addEventListener('dragleave', this.handleDragLeave.bind(this));
            zone.addEventListener('click', this.handleZoneClick.bind(this));
        });
    }

    checkAnswer() {
        const exercise = Selectors.getCurrentExercise();
        const currentIndex = Selectors.getCurrentExerciseIndex();
        
        if (!exercise) return;

        let isCorrect = false;
        let feedback = '';

        if (exercise.type === 'fill-blank') {
            isCorrect = this.checkFillBlankAnswer(exercise);
            feedback = isCorrect ? 'Excellent! All blanks are correct.' : 'Some answers need correction. Check the highlighted fields.';
        } else if (exercise.type === 'drag-drop') {
            isCorrect = this.checkDragDropAnswer(exercise);
            feedback = isCorrect ? 'Perfect! The code is in the correct order.' : 'The order is not quite right. Try rearranging the lines.';
        }

        // Update state
        this.dispatch(Actions.setUserAnswer(currentIndex, isCorrect));

        // Show result
        this.showResult(isCorrect, feedback, exercise.explanation);

        // Update button states
        const checkBtn = document.getElementById('check-btn');
        const nextBtn = document.getElementById('next-btn');
        
        if (checkBtn) {
            checkBtn.textContent = isCorrect ? 'Correct! ‚úì' : 'Try Again';
            checkBtn.disabled = isCorrect;
        }
        
        if (nextBtn) {
            nextBtn.disabled = !isCorrect;
        }
    }

    checkFillBlankAnswer(exercise) {
        const blanks = document.querySelectorAll('.blank');
        let allCorrect = true;

        console.log('=== VALIDATION DEBUG ===');
        console.log('Exercise blanks:', exercise.blanks);

        blanks.forEach((blank, index) => {
            const userAnswer = blank.value.trim();
            const correctAnswer = exercise.blanks[index].answer;
            
            const isCorrect = userAnswer === correctAnswer || userAnswer.toLowerCase() === correctAnswer.toLowerCase();
            
            console.log(`Blank ${index + 1}:`);
            console.log(`  Expected: "${correctAnswer}"`);
            console.log(`  User input: "${userAnswer}"`);
            console.log(`  Match: ${isCorrect}`);
            
            blank.classList.remove('correct', 'incorrect');
            blank.classList.add(isCorrect ? 'correct' : 'incorrect');
            
            if (!isCorrect) {
                allCorrect = false;
                if (!userAnswer) {
                    blank.placeholder = `Expected: ${correctAnswer}`;
                }
            } else {
                blank.placeholder = '';
            }
        });

        console.log('All correct:', allCorrect);
        console.log('========================');

        return allCorrect;
    }

    checkDragDropAnswer(exercise) {
        const dropZones = document.querySelectorAll('.drop-zone');
        let allCorrect = true;

        dropZones.forEach((zone, index) => {
            zone.classList.remove('correct', 'incorrect');
            
            if (zone.hasChildNodes()) {
                const item = zone.firstElementChild;
                const userLineIndex = parseInt(item.dataset.lineIndex);
                const correctLineIndex = exercise.correctOrder[index];
                const isCorrect = userLineIndex === correctLineIndex;
                
                zone.classList.add(isCorrect ? 'correct' : 'incorrect');
                
                if (!isCorrect) {
                    allCorrect = false;
                }
            } else {
                zone.classList.add('incorrect');
                allCorrect = false;
            }
        });

        return allCorrect;
    }

    showResult(isCorrect, feedback, explanation) {
        const resultContainer = document.getElementById('result-container');
        const resultIcon = document.getElementById('result-icon');
        const resultText = document.getElementById('result-text');
        const resultExplanation = document.getElementById('result-explanation');

        if (resultIcon) resultIcon.textContent = isCorrect ? '‚úÖ' : '‚ùå';
        if (resultText) resultText.textContent = feedback;
        if (resultExplanation) resultExplanation.textContent = explanation;

        if (resultContainer) {
            resultContainer.className = `result ${isCorrect ? 'success' : 'error'}`;
            resultContainer.style.display = 'block';

            if (isCorrect) {
                resultContainer.classList.add('success-animation');
                setTimeout(() => resultContainer.classList.remove('success-animation'), 600);
            }
        }
    }

    updateNavigationButtons() {
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const checkBtn = document.getElementById('check-btn');
        
        if (prevBtn) prevBtn.disabled = !Selectors.canGoPrev();
        if (nextBtn) nextBtn.disabled = !Selectors.canGoNext();
        
        // Reset check button for new exercise
        if (checkBtn) {
            checkBtn.textContent = 'Check Answer';
            checkBtn.disabled = false;
        }
    }

    updateUI(uiState) {
        // Handle README modal
        const readmeModal = document.getElementById('readme-modal');
        if (readmeModal) {
            readmeModal.style.display = uiState.showReadme ? 'flex' : 'none';
            
            if (uiState.showReadme) {
                this.showReadmeContent();
            }
        }

        // Handle loading state
        if (uiState.loading) {
            // Could add loading spinner here
            console.log('Loading exercise...');
        }

        // Handle error state
        if (uiState.error) {
            console.error('UI Error:', uiState.error);
        }
    }

    showReadmeContent() {
        const currentExercise = Selectors.getCurrentExercise();
        const readmeContentEl = document.getElementById('readme-content');
        
        if (currentExercise && currentExercise.readme && readmeContentEl) {
            readmeContentEl.innerHTML = this.convertMarkdownToHtml(currentExercise.readme);
        } else if (readmeContentEl) {
            readmeContentEl.innerHTML = '<p>README not available for this exercise.</p>';
        }
    }

    async regenerateExercise() {
        const currentIndex = Selectors.getCurrentExerciseIndex();
        
        // Clear cache to force regeneration
        const cache = [...(Selectors.getExerciseCache() || [])];
        cache[currentIndex] = null;
        this.dispatch(Actions.setState({ exerciseCache: cache }, 'CLEAR_EXERCISE_CACHE'));
        
        // Show loading state
        const regenerateBtn = document.getElementById('regenerate-btn');
        if (regenerateBtn) {
            regenerateBtn.textContent = 'üîÑ Generating...';
            regenerateBtn.disabled = true;
        }
        
        // Load new variation
        await this.loadExercise(currentIndex);
        
        // Reset button
        if (regenerateBtn) {
            regenerateBtn.textContent = 'üé≤ New Variation';
            regenerateBtn.disabled = false;
        }
        
        // Hide result
        const resultContainer = document.getElementById('result-container');
        if (resultContainer) resultContainer.style.display = 'none';
    }

    // Drag and drop handlers (keeping your existing logic)
    handleDragStart(e) {
        this.draggedElement = e.target;
        e.target.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
    }

    handleDragEnd(e) {
        e.target.classList.remove('dragging');
        this.draggedElement = null;
    }

    handleDragOver(e) {
        e.preventDefault();
        e.target.classList.add('drag-over');
    }

    handleDragLeave(e) {
        e.target.classList.remove('drag-over');
    }

    handleDrop(e) {
        e.preventDefault();
        e.target.classList.remove('drag-over');
        
        if (this.draggedElement && e.target.children.length === 0) {
            this.moveItemToZone(this.draggedElement, e.target);
        }
    }

    handleZoneClick(e) {
        if (e.target.children.length > 0) {
            const item = e.target.firstElementChild;
            const dragOptions = document.getElementById('drag-options');
            if (dragOptions) {
                dragOptions.appendChild(item);
                e.target.textContent = `Drop line ${parseInt(e.target.dataset.position) + 1} here...`;
                e.target.classList.remove('filled');
            }
        }
    }

    moveItemToZone(item, zone) {
        const dragOptions = document.getElementById('drag-options');
        
        if (zone.children.length > 0 && dragOptions) {
            dragOptions.appendChild(zone.firstElementChild);
        }
        
        zone.textContent = '';
        zone.appendChild(item);
        zone.classList.add('filled');
        zone.classList.remove('correct', 'incorrect');
    }

    // Utility methods
    convertMarkdownToHtml(markdown) {
        let html = markdown;
        
        html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
        html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
        html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
        html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
        html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        html = html.replace(/^> (.*$)/gm, '<blockquote>$1</blockquote>');
        html = html.replace(/\n/g, '<br>');
        
        return html;
    }

    getDifficultyName(difficulty) {
        switch (difficulty) {
            case 0.25: return 'Easy';
            case 0.5: return 'Medium';
            case 0.75: return 'Hard';
            default: return 'Medium';
        }
    }
}

// Initialize the app when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.app = new TrainerApp();
    
    // Development shortcuts (only in localhost)
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        console.log('üöÄ Java Trainer loaded with state management!');
        console.log('üí° Try these in console: app.getState(), DevTools.logState()');
    }
});

// Initialize the app
document.addEventListener('DOMContentLoaded', function() {
  // Initialize dynamic exercise generator with stored config
  const config = getStoredConfig();
  exerciseGenerator = new DynamicExerciseGenerator(config);
  
  // Show config summary
  displayConfigSummary(config);
  
  // Load first exercise dynamically
  loadDynamicExercise(0);
  
  updateProgress();
  setupEventListeners();
});

// Get configuration from homepage
function getStoredConfig() {
  const stored = localStorage.getItem('trainingConfig');
  if (stored) {
    return JSON.parse(stored);
  }
  
  // Default configuration
  return {
    tasks: 5,
    levels: ['g1', 'g2'],
    difficulty: 0.5
  };
}

// Display current session configuration
function displayConfigSummary(config) {
  const levelNames = config.levels.map(level => level.toUpperCase()).join(', ');
  const difficultyName = getDifficultyName(config.difficulty);
  
  // Add config display to page
  const configDisplay = document.createElement('div');
  configDisplay.className = 'config-display';
  configDisplay.innerHTML = `
    <div class="session-info">
      üìä ${config.tasks} tasks ‚Ä¢ üéì ${levelNames} ‚Ä¢ üî• ${difficultyName} (${Math.round(config.difficulty * 100)}%)
      <button class="config-change-btn" onclick="window.location.href='index.html'">‚öôÔ∏è Change</button>
    </div>
  `;
  
  const container = document.querySelector('.container');
  if (container) {
    container.insertBefore(configDisplay, container.firstChild);
  }
}

function getDifficultyName(difficulty) {
  switch (difficulty) {
    case 0.25: return 'Easy';
    case 0.5: return 'Medium';
    case 0.75: return 'Hard';
    default: return 'Medium';
  }
}

// Setup event listeners
function setupEventListeners() {
  prevBtn.addEventListener('click', showPreviousExercise);
  nextBtn.addEventListener('click', showNextExercise);
  checkBtn.addEventListener('click', checkAnswer);
  readmeBtn.addEventListener('click', showReadme);
  closeReadme.addEventListener('click', hideReadme);
  regenerateBtn.addEventListener('click', regenerateExercise);
  readmeModal.addEventListener('click', function(e) {
    if (e.target === readmeModal) {
      hideReadme();
    }
  });
}

// Load dynamic exercise
async function loadDynamicExercise(index) {
  try {
    const exerciseList = exerciseGenerator.getExerciseList();
    if (index >= exerciseList.length) {
      console.error('Exercise index out of range');
      return;
    }
    
    // Check if already loaded and cached
    if (!loadedExercises[index]) {
      const exerciseId = exerciseList[index].id;
      loadedExercises[index] = await exerciseGenerator.loadExercise(exerciseId);
    }
    
    const exercise = loadedExercises[index];
    loadExercise(exercise, index);
    
  } catch (error) {
    console.error('Failed to load dynamic exercise:', error);
  }
}

// Load and display an exercise (updated to handle both static and dynamic)
function loadExercise(exercise, index = currentExerciseIndex) {
  if (!exercise) {
    console.error('No exercise data provided');
    return;
  }
  if (!exercise) return;

  // Clear previous content
  exerciseContainer.innerHTML = '';
  resultContainer.style.display = 'none';
  
  // Reset check button
  checkBtn.textContent = 'Check Answer';
  checkBtn.disabled = false;

  // Create exercise HTML
  const exerciseHTML = `
    <div class="level-badge ${exercise.level}">${exercise.level.toUpperCase()}</div>
    <h2 class="exercise-title">${exercise.title}</h2>
    <p class="exercise-description">${exercise.description}</p>
    ${exercise.type === 'fill-blank' ? createFillBlankHTML(exercise) : createDragDropHTML(exercise)}
  `;

  exerciseContainer.innerHTML = exerciseHTML;

  // Add event listeners for the specific exercise type
  if (exercise.type === 'fill-blank') {
    setupFillBlankListeners();
  } else if (exercise.type === 'drag-drop') {
    setupDragDropListeners();
  }
}

// Create HTML for fill-in-the-blank exercises
function createFillBlankHTML(exercise) {
  let codeWithBlanks = exercise.code;
  let blankIndex = 0;

  // Replace each _____ with an input field
  codeWithBlanks = codeWithBlanks.replace(/_____/g, function() {
    return `<input type="text" class="blank" data-blank-index="${blankIndex++}" autocomplete="off" spellcheck="false">`;
  });

  return `
    <div class="code-snippet">
      <pre><code>${codeWithBlanks}</code></pre>
    </div>
  `;
}

// Create HTML for drag-and-drop exercises
function createDragDropHTML(exercise) {
  const shuffledLines = [...exercise.lines].sort(() => Math.random() - 0.5);
  
  return `
    <div class="drag-container">
      <div class="drag-options" id="drag-options">
        ${shuffledLines.map((line, index) => 
          `<div class="drag-item" draggable="true" data-line-index="${exercise.lines.indexOf(line)}" data-content="${line.replace(/"/g, '&quot;')}">${line || '(empty line)'}</div>`
        ).join('')}
      </div>
      
      <div class="code-snippet">
        <div class="drop-zones">
          ${exercise.lines.map((_, index) => 
            `<div class="drop-zone" data-position="${index}">Drop line ${index + 1} here...</div>`
          ).join('')}
        </div>
      </div>
    </div>
  `;
}

// Setup event listeners for fill-in-the-blank exercises
function setupFillBlankListeners() {
  const blanks = document.querySelectorAll('.blank');
  blanks.forEach(blank => {
    blank.addEventListener('input', function() {
      // Clear any previous styling
      this.classList.remove('correct', 'incorrect');
    });
    
    blank.addEventListener('keydown', function(e) {
      // Allow spacebar and other keys
      if (e.key === 'Enter') {
        checkAnswer();
      }
      // Don't prevent default for spacebar - let it work normally
    });
    
    // Focus next input on Tab
    blank.addEventListener('keydown', function(e) {
      if (e.key === 'Tab') {
        e.preventDefault();
        const blanks = document.querySelectorAll('.blank');
        const currentIndex = Array.from(blanks).indexOf(this);
        if (currentIndex < blanks.length - 1) {
          blanks[currentIndex + 1].focus();
        }
      }
    });
  });
}

// Setup event listeners for drag-and-drop exercises
function setupDragDropListeners() {
  const dragItems = document.querySelectorAll('.drag-item');
  const dropZones = document.querySelectorAll('.drop-zone');

  // Touch and mouse events for drag items
  dragItems.forEach(item => {
    // Mouse events
    item.addEventListener('dragstart', handleDragStart);
    item.addEventListener('dragend', handleDragEnd);
    
    // Touch events for mobile
    item.addEventListener('touchstart', handleTouchStart, { passive: false });
    item.addEventListener('touchmove', handleTouchMove, { passive: false });
    item.addEventListener('touchend', handleTouchEnd);
  });

  // Drop zone events
  dropZones.forEach(zone => {
    zone.addEventListener('dragover', handleDragOver);
    zone.addEventListener('drop', handleDrop);
    zone.addEventListener('dragleave', handleDragLeave);
    zone.addEventListener('click', handleZoneClick);
  });
}

// Drag and drop handlers
let draggedElement = null;
let touchStartPos = { x: 0, y: 0 };

function handleDragStart(e) {
  draggedElement = this;
  this.classList.add('dragging');
  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/html', this.outerHTML);
}

function handleDragEnd(e) {
  this.classList.remove('dragging');
  draggedElement = null;
}

function handleDragOver(e) {
  e.preventDefault();
  this.classList.add('drag-over');
}

function handleDragLeave(e) {
  this.classList.remove('drag-over');
}

function handleDrop(e) {
  e.preventDefault();
  this.classList.remove('drag-over');
  
  if (draggedElement && this.children.length === 0) {
    // Move the element to this drop zone
    moveItemToZone(draggedElement, this);
  }
}

function handleZoneClick(e) {
  // Allow clicking to remove items from drop zones
  if (this.children.length > 0) {
    const item = this.firstElementChild;
    const dragOptions = document.getElementById('drag-options');
    dragOptions.appendChild(item);
    this.textContent = `Drop line ${parseInt(this.dataset.position) + 1} here...`;
    this.classList.remove('filled');
  }
}

// Touch event handlers for mobile
function handleTouchStart(e) {
  const touch = e.touches[0];
  touchStartPos = { x: touch.clientX, y: touch.clientY };
  draggedElement = this;
  this.classList.add('dragging');
}

function handleTouchMove(e) {
  e.preventDefault();
  if (!draggedElement) return;
  
  const touch = e.touches[0];
  const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
  
  // Remove previous drag-over states
  document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
  
  // Add drag-over state to drop zones
  if (elementBelow && elementBelow.classList.contains('drop-zone')) {
    elementBelow.classList.add('drag-over');
  }
}

function handleTouchEnd(e) {
  if (!draggedElement) return;
  
  const touch = e.changedTouches[0];
  const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
  
  // Remove drag states
  document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
  draggedElement.classList.remove('dragging');
  
  // Handle drop
  if (elementBelow && elementBelow.classList.contains('drop-zone') && elementBelow.children.length === 0) {
    moveItemToZone(draggedElement, elementBelow);
  }
  
  draggedElement = null;
}

// Move item to drop zone
function moveItemToZone(item, zone) {
  const dragOptions = document.getElementById('drag-options');
  
  // If zone already has an item, return it to options
  if (zone.children.length > 0) {
    dragOptions.appendChild(zone.firstElementChild);
  }
  
  // Clear the text content and move the dragged item to the zone
  zone.textContent = '';
  zone.appendChild(item);
  zone.classList.add('filled');
  
  // Clear any previous results
  zone.classList.remove('correct', 'incorrect');
}

// Check the user's answer
function checkAnswer() {
  // Get the current exercise from loaded dynamic exercises
  const exercise = loadedExercises[currentExerciseIndex];
  
  if (!exercise) {
    console.error('No exercise found for validation');
    return;
  }
  
  let isCorrect = false;
  let feedback = '';

  if (exercise.type === 'fill-blank') {
    isCorrect = checkFillBlankAnswer(exercise);
    feedback = isCorrect ? 'Excellent! All blanks are correct.' : 'Some answers need correction. Check the highlighted fields.';
  } else if (exercise.type === 'drag-drop') {
    isCorrect = checkDragDropAnswer(exercise);
    feedback = isCorrect ? 'Perfect! The code is in the correct order.' : 'The order is not quite right. Try rearranging the lines.';
  }

  // Show result
  showResult(isCorrect, feedback, exercise.explanation);
  
  // Update button states
  checkBtn.textContent = isCorrect ? 'Correct! ‚úì' : 'Try Again';
  checkBtn.disabled = isCorrect;
  nextBtn.disabled = !isCorrect;
  
  // Store answer
  userAnswers[currentExerciseIndex] = isCorrect;
}

// Check fill-in-the-blank answers with exact matching validation
function checkFillBlankAnswer(exercise) {
  const blanks = document.querySelectorAll('.blank');
  let allCorrect = true;

  console.log('=== VALIDATION DEBUG ===');
  console.log('Exercise blanks:', exercise.blanks);

  blanks.forEach((blank, index) => {
    const userAnswer = blank.value.trim();
    const correctAnswer = exercise.blanks[index].answer;
    
    // Exact matching validation as suggested
    const isCorrect = userAnswer === correctAnswer || userAnswer.toLowerCase() === correctAnswer.toLowerCase();
    
    console.log(`Blank ${index + 1}:`);
    console.log(`  Expected: "${correctAnswer}"`);
    console.log(`  User input: "${userAnswer}"`);
    console.log(`  Match: ${isCorrect}`);
    
    blank.classList.remove('correct', 'incorrect');
    blank.classList.add(isCorrect ? 'correct' : 'incorrect');
    
    if (!isCorrect) {
      allCorrect = false;
      
      // Optional: Set placeholder to show expected answer (but only if field is empty)
      if (!userAnswer) {
        blank.placeholder = `Expected: ${correctAnswer}`;
      }
    } else {
      blank.placeholder = ''; // Clear placeholder on correct answer
    }
  });

  console.log('All correct:', allCorrect);
  console.log('========================');

  return allCorrect;
}

// Check drag-and-drop answers
function checkDragDropAnswer(exercise) {
  const dropZones = document.querySelectorAll('.drop-zone');
  let allCorrect = true;

  dropZones.forEach((zone, index) => {
    zone.classList.remove('correct', 'incorrect');
    
    if (zone.hasChildNodes()) {
      const item = zone.firstElementChild;
      const userLineIndex = parseInt(item.dataset.lineIndex);
      const correctLineIndex = exercise.correctOrder[index];
      const isCorrect = userLineIndex === correctLineIndex;
      
      zone.classList.add(isCorrect ? 'correct' : 'incorrect');
      
      if (!isCorrect) {
        allCorrect = false;
      }
    } else {
      zone.classList.add('incorrect');
      allCorrect = false;
    }
  });

  return allCorrect;
}

// Show result with animation
function showResult(isCorrect, feedback, explanation) {
  const resultIcon = document.getElementById('result-icon');
  const resultText = document.getElementById('result-text');
  const resultExplanation = document.getElementById('result-explanation');

  resultIcon.textContent = isCorrect ? '‚úÖ' : '‚ùå';
  resultText.textContent = feedback;
  resultExplanation.textContent = explanation;

  resultContainer.className = `result ${isCorrect ? 'success' : 'error'}`;
  resultContainer.style.display = 'block';

  if (isCorrect) {
    resultContainer.classList.add('success-animation');
    setTimeout(() => resultContainer.classList.remove('success-animation'), 600);
  }
}

// Navigation functions
function showPreviousExercise() {
  if (currentExerciseIndex > 0) {
    currentExerciseIndex--;
    loadDynamicExercise(currentExerciseIndex);
    updateProgress();
    updateNavigationButtons();
  }
}

function showNextExercise() {
  const totalExercises = exerciseGenerator ? exerciseGenerator.getExerciseList().length : exercises.length;
  if (currentExerciseIndex < totalExercises - 1) {
    currentExerciseIndex++;
    loadDynamicExercise(currentExerciseIndex);
    updateProgress();
    updateNavigationButtons();
  }
}

// Update progress display
function updateProgress() {
  const totalExercises = exerciseGenerator ? exerciseGenerator.getExerciseList().length : 0;
  const progress = totalExercises > 0 ? ((currentExerciseIndex + 1) / totalExercises) * 100 : 0;
  progressFill.style.width = `${progress}%`;
  progressText.textContent = `Exercise ${currentExerciseIndex + 1} of ${totalExercises}`;
}

// README functionality
function showReadme() {
  // Get README from current loaded exercise
  const currentExercise = loadedExercises[currentExerciseIndex];
  if (currentExercise && currentExercise.readme) {
    readmeContentEl.innerHTML = convertMarkdownToHtml(currentExercise.readme);
    readmeModal.style.display = 'flex';
    return;
  }
  
  // No README available
  readmeContentEl.innerHTML = '<p>README not available for this exercise.</p>';
  readmeModal.style.display = 'flex';
}

function hideReadme() {
  readmeModal.style.display = 'none';
}

// Regenerate current exercise with new random blanks
async function regenerateExercise() {
  if (!exerciseGenerator) {
    console.log('Dynamic exercise generator not available');
    return;
  }
  
  try {
    // Clear the cached exercise to force regeneration
    loadedExercises[currentExerciseIndex] = null;
    
    // Show loading state
    regenerateBtn.textContent = 'üîÑ Generating...';
    regenerateBtn.disabled = true;
    
    // Load new variation
    await loadDynamicExercise(currentExerciseIndex);
    
    // Reset button
    regenerateBtn.textContent = 'üé≤ New Variation';
    regenerateBtn.disabled = false;
    
    // Clear any previous results
    hideResult();
    
  } catch (error) {
    console.error('Failed to regenerate exercise:', error);
    regenerateBtn.textContent = 'üé≤ New Variation';
    regenerateBtn.disabled = false;
  }
}

// Hide result display
function hideResult() {
  resultContainer.style.display = 'none';
}

// Simple markdown to HTML converter
function convertMarkdownToHtml(markdown) {
  let html = markdown;
  
  // Code blocks
  html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
  
  // Inline code
  html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
  
  // Headers
  html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
  html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
  
  // Bold
  html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
  
  // Blockquotes (üí° tips)
  html = html.replace(/^> (.*$)/gm, '<blockquote>$1</blockquote>');
  
  // Line breaks
  html = html.replace(/\n/g, '<br>');
  
  return html;
}

// Update navigation button states
function updateNavigationButtons() {
  const totalExercises = exerciseGenerator ? exerciseGenerator.getExerciseList().length : 0;
  
  prevBtn.disabled = currentExerciseIndex === 0;
  nextBtn.disabled = currentExerciseIndex >= totalExercises - 1 || !userAnswers[currentExerciseIndex];
  
  // Reset check button for new exercise
  checkBtn.textContent = 'Check Answer';
  checkBtn.disabled = false;
}

// Keyboard navigation
document.addEventListener('keydown', function(e) {
  if (e.key === 'ArrowLeft' && !prevBtn.disabled) {
    showPreviousExercise();
  } else if (e.key === 'ArrowRight' && !nextBtn.disabled) {
    showNextExercise();
  } else if (e.key === ' ' && !checkBtn.disabled) {
    e.preventDefault();
    checkAnswer();
  }
});

// Prevent default drag behavior on images and other elements
document.addEventListener('dragstart', function(e) {
  if (!e.target.classList.contains('drag-item')) {
    e.preventDefault();
  }
});

// Initialize navigation buttons
updateNavigationButtons();